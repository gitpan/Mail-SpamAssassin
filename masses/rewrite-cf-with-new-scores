#!/usr/bin/perl -w

my $oldscores = $ARGV[0];
my $newscores = $ARGV[1];

if (!defined $newscores) {
  die "usage: rewrite-cf-with-new-scores oldscores.cf newscores.cf\n";
}

# read the skipped scores and their previous values
my %skipped_scores = ();
my ($name, $base, $muta);
open (IN, "<tmp/scores.data");
while (<IN>) {
  chomp;
  /^n(.*)$/ and $name = $1;
  /^b(.*)$/ and $base = $1;
  /^m(.*)$/ and $muta = $1;

  if (/^\./ && defined($name)) {
    if ($name =~ /^__/             # meta-test subrules
        || $muta == 0)             # otherwise non-mutable
      { $skipped_scores{$name} = $base; }
  }
}
if ($muta == 0) { $skipped_scores{$name} = $base; }
close IN;

system ("./parse-rules-for-masses") and die;
require "./tmp/rules.pl";

# now read the evolved scores
my @gascoreorder = ();
my %gascorelines = ();
open (STDIN, "<$newscores") or die "cannot open $newscores";
while (<STDIN>) {
  /^score\s+(\S+)\s/ or next;
  my $name = $1;
  next unless (exists ($rules{$name}) && $rules{$name}->{issubrule} == 0);
  next if ($name =~ /^__/);
  next if (defined $skipped_scores{$name});
  next if ($name eq '(null)');	# er, oops ;)

  $gascorelines{$1} = $_;
  push (@gascoreorder, $1);
}

open (IN, "<$oldscores") or die "cannot open $oldscores";
my $out = '';
my $pre = '';

# read until '# Start of GA-evolved scores', removing scores from our
# new list if we come across them.
while (<IN>) {
  if (/^\s*score\s+(\S+)\s/) {
    delete $skipped_scores{$1};
    delete $gascorelines{$1};
    next unless (exists ($rules{$name}) && $rules{$name}->{issubrule} == 0);
  }
  $pre .= $_;
  /^# Start of GA-evolved scores/ and last;
}

# now skip until '# End of GA-evolved scores'
while (<IN>) {
  /^# End of GA-evolved scores/ and last;
}
if (defined $_) {
  $out .= $_;
}

# and read until EOF, again removing scores from our list as we find 'em.
while (<IN>) {
  if (/^\s*score\s+(\S+)\s/) {
    my $name = $1;

    next unless (exists ($rules{$name}) && $rules{$name}->{issubrule} == 0);
    if (defined $gascorelines{$name}) {
      $_ = $gascorelines{$name};
    }
    delete $skipped_scores{$name};
    delete $gascorelines{$name};
  }
  $out .= $_;
}
close IN;

# finally, make a string of the scores that were not in either list
my $missing = '';
foreach my $name (sort keys %skipped_scores) {
  next unless (exists ($rules{$name}) && $rules{$name}->{issubrule} == 0);
  $missing .= sprintf ("score %-30s %3.1f\n", $name, $skipped_scores{$name});
}

# and output the lot
print $pre, "\n";
foreach my $name (@gascoreorder) {
  $_ = $gascorelines{$name};
  next unless (defined ($_));
  print $_;
}
print "\n", $out, "\n";
if ($missing ne '') { print "# Missed scores:\n\n", $missing; }

